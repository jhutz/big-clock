#!/usr/bin/env python

import BaseHTTPServer
import SimpleHTTPServer
import socket
import struct
import hashlib
import threading
import base64
import array
import time
import json
import os
import sys
import csv
from traceback import format_exc as format

maxMessageLen = 1024
wsPingPeriod = 15
wsMaxPings = 3
server_version = '0.9'

def log(peer, msg):
    preamble = time.strftime('%b %d %H:%M:%S')
    if peer != None:
        preamble += ' ' + peer
    print(preamble + ' ' + msg)


class MyHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    protocol_version = "HTTP/1.0"
    def end_headers(self):
        self.send_my_headers()
        SimpleHTTPServer.SimpleHTTPRequestHandler.end_headers(self)

    def send_my_headers(self):
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "Thu, 01 Dec 1994 16:00:00 GMT")
        self.send_header("Max-Age", "0")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Cache-Control", "must-revalidate")

    def list_directory(self, path):
        self.send_error(404, "No permission to list directory")
        return None

# WebSocket server code adapted from
# https://gist.github.com/sadatanwar/222d4643c25f72293461

class WSProtocolError(Exception): pass
class WSHandshakeError(WSProtocolError): pass

GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

def create_hash(key):
    reply = key + GUID
    sh1 = hashlib.sha1(reply)
    return sh1.digest()

def parse_headers(data, headers):
    lines = data.splitlines()
    for l in lines:
        if l == '':
            headers[None] = True
            return
        if '' not in headers:
            headers[''] = l.split()
            continue
        parts = l.split(": ", 1)
        if len(parts) == 2:
            headers[parts[0]] = parts[1]

# Conduct handshake.  Possible return values:
#   - 'WS'       WebSocket client
#   - 'CONSOLE'  console client (accepts console commands)
#   - 'MONITOR'  monitor client (read-only)
def handshake(conn, peer):
    log(peer, 'Starting handshake')
    headers = {}
    while None not in headers:
        data = conn.recv(1024)
        if not data: raise EOFError
        parse_headers(data, headers)
        if headers[''][0].upper() == 'CONSOLE':
            log(peer, 'console client')
            return 'CONSOLE'
        if headers[''][0].upper() == 'MONITOR':
            log(peer, 'monitor client')
            return 'MONITOR'

    if 'Sec-WebSocket-Key' not in headers:
        raise(WSHandshakeError('missing Sec-WebSocket-Key'))
    digest = create_hash(
        headers['Sec-WebSocket-Key']
    )
    encoded_data = base64.b64encode(digest)
    shake = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n"
    shake += "Upgrade: WebSocket\r\n"
    shake += "Connection: Upgrade\r\n"
    shake += "Sec-WebSocket-Accept: %s\r\n\r\n" % encoded_data
    conn.send(shake)
    log(peer, 'WebSocket handshake successful')
    return 'WS'


class WebSocketServer(object):
    def __init__(self, port):
        self.clients = {}
        self.port = port
        self.SERVER_ACTIVE = True
        self.POLLER_ACTIVE = False
        self.lock = threading.Lock()
        self.new_client_data = {}

    def _initClient(self,client):
        self.sendJSON([':V', server_version], clients=[client])
        for item in sorted(self.new_client_data.items()):
            self.sendJSON(item[1], clients=[client])

    def _bindClient(self):
        log(None, 'waiting connection')
        s = socket.socket()
        s.settimeout(5)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', self.port))
        s.listen(10)
        while self.SERVER_ACTIVE:
            try:
                conn, addr = s.accept()
            except Exception, e:
                err = e.args[0]
                if err == 'timed out':
                    continue
                print(format())
                print(e)
                self.SERVER_ACTIVE = False
                return
            peer = '%s:%d' % addr
            log(peer, 'Client connected')
            try:
                conn.settimeout(5)
                clientType = handshake(conn, peer)
                clientCode = conn.__hash__()
                client = {
                        'id': clientCode,
                        'peer': peer,
                        'conn': conn,
                        'type': clientType,
                        'squelch': False,
                        'alive': True,
                        'last_pong': time.time()
                        }
                with self.lock:
                    self._initClient(client)
                    self.clients[clientCode] = client
                    conn = None
                    if clientType == 'WS':
                        client_thr = threading.Thread(target=self._wsClient,
                                args=(client,))
                        client_thr.name = 'client ' + peer
                        client_thr.daemon = True
                        client_thr.start()
                    if clientType == 'CONSOLE':
                        client['squelch'] = True
                        client_thr = threading.Thread(target=self._consClient,
                                args=(client,))
                        client_thr.name = 'client ' + peer
                        client_thr.daemon = True
                        client_thr.start()
                    if not self.POLLER_ACTIVE:
                        self.POLLER_ACTIVE = True
                        poller_thr = threading.Thread(target=self._poll)
                        poller_thr.name = 'poller'
                        poller_thr.daemon = True
                        poller_thr.start()
            except Exception, e:
                if conn: conn.close()
                log(peer, str(type(e)))
                print(format())
                print(e)
        log(None, 'Shutting down WS server port: %s' % self.port)
        return

    def _wsClient(self, client):
        conn = client['conn']
        payload = array.array('B')
        datatype = 0
        while client['alive']:
            try:
                # receive header
                data = conn.recv(2)
                if not data: raise EOFError
                head1, head2 = struct.unpack('!BB', data)
                fin = bool(head1 & 0b10000000)
                isctrl = head1 & 0b00001000
                opcode = head1 & 0b00001111
                length = head2 & 0b01111111
                if length == 126:
                    data = conn.recv(2)
                    if not data: raise EOFError
                    length, = struct.unpack('!H', data)
                elif length == 127:
                    data = conn.recv(8)
                    if not data: raise EOFError
                    length, = struct.unpack('!Q', data)
                mask_bits = conn.recv(4)
                if not mask_bits: raise EOFError
                mask_bits = bytearray(mask_bits)

                # validation
                if not payload and not opcode:
                    raise WSProtocolError('no opcode in initial packet')
                if payload and opcode and not isctrl:
                    raise WSProtocolError('opcode in non-initial packet')
                if isctrl and not fin:
                    raise WSProtocolError('fragmented control packet')
                if not head2 & 0b10000000:
                    raise WSProtocolError('client data not masked')
                if isctrl and length > 125:
                    raise WSProtocolError('control message too long (%d > 125)'
                            % (length))
                if length > maxMessageLen:
                    raise WSProtocolError('packet too long (%d > %d)'
                            % (length, maxMessageLen))
                if length > maxMessageLen - len(payload):
                    raise WSProtocolError('message too long (%d + %d > %d)'
                            % (len(payload), length, maxMessageLen))

                # receive and decode data
                data = conn.recv(length)
                if not data: raise EOFError
                data = bytearray(data)
                DECODED = []
                for i in range(0, len(data)):
                    DECODED.append(data[i] ^ mask_bits[i % 4])

            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if isctrl:
                data = array.array('B', DECODED).tostring()
            else:
                payload.extend(DECODED)
                if opcode: datatype = opcode
                if not fin: continue
                data = payload.tostring()
                del payload[:]

            # handle complete messages
            if opcode == 0x8: # close
                log(client['peer'], 'disconnected')
                self._remove(client)
            elif opcode == 0x9: # ping
                self.sendData(data, opcode=0xa, clients=[client])
            elif opcode == 0xa or (not isctrl and data == "pong"): # pong
                client['last_pong'] = time.time()
                log(client['peer'], 'pong')
            elif isctrl:
                log(client['peer'], 'unknown control message %x' % opcode)
            else:
                self.handleData(client, datatype, data)

    def _consClient(self, client):
        conn = client['conn']
        conn.setblocking(True)
        f = conn.makefile('rU')
        while client['alive']:
            try:
                data = f.readline().strip()
                if not data: raise EOFError
            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if data == "pong":
                client['last_pong'] = time.time()
            elif data[0] == ':':
                self.consoleCommand(client, data[1:].split())
            elif data[0] == '+':
                self.sendMessage(data[1:])
            elif data[0] == '!':
                self.sendError(data[1:])
            else:
                self.handleData(client, 1, data)

    def _poll(self):
        pingTimeout = wsPingPeriod * wsMaxPings + 3
        try:
            while self.SERVER_ACTIVE:
                log(None, 'Pinging %d clients' % len(self.clients))
                self.sendData('ping')
                now = time.time()
                for client in self.clients.values():
                    if client['type'] != 'WS': continue
                    if not client['alive']: continue
                    if now - client['last_pong'] > pingTimeout:
                        log(client['peer'], 'Client timed out')
                        self._remove(client)
                with self.lock:
                    if len(self.clients) == 0:
                        log(None, 'No Clients, shutting down poller')
                        self.POLLER_ACTIVE = False
                        return
                time.sleep(wsPingPeriod)
        except Exception, e:
            self.POLLER_ACTIVE = False
            print(format())
            print(e)

    def startServer(self):
        ws_server_thr = threading.Thread(target=self._bindClient)
        ws_server_thr.name = 'WS Listener'
        ws_server_thr.daemon = True
        ws_server_thr.start()

    def sendData(self, data, fin=True, opcode=1, masking_key=False,
            clients=None, allClients=False):
        if fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')
        if 0x3 <= opcode <= 0x7 or 0xB <= opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------++-+-------------+-------------------------------+
        ## |F|R|R|R| opcode||M| Payload len |    Extended payload length    |
        ## |I|S|S|S|  (4)  ||A|     (7)     |             (16/63)           |
        ## |N|V|V|V|       ||S|             |   (if payload len==126/127)   |
        ## | |1|2|3|       ||K|             |                               |
        ## +-+-+-+-+-------++-+-------------+ - - - - - - - - - - - - - - - +
        ## +-+-+-+-+--------------------------------------------------------+
        ## |     Extended payload length continued, if payload len == 127   |
        ## + - - - - - - - - - - - - - - - +--------------------------------+
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        try:
            header = struct.pack('!B', ((fin << 7)
                                        | (0 << 6)
                                        | (0 << 5)
                                        | (0 << 4)
                                        | opcode))
            if masking_key:
                mask_bit = 1 << 7
            else:
                mask_bit = 0

            length = len(data)
            if length < 126:
                header += struct.pack('!B', (mask_bit | length))
            elif length < (1 << 16):
                header += struct.pack('!B', (mask_bit | 126)) + struct.pack('!H', length)
            elif length < (1 << 63):
                header += struct.pack('!B', (mask_bit | 127)) + struct.pack('!Q', length)

            body = data
            if clients == None:
                with self.lock: clients = self.clients.values()
                if not allClients:
                    clients = [c for c in clients if not c['squelch']]
            for client in clients:
                try:
                    if client['type'] == 'WS':
                        client['conn'].send(bytes(header + body))
                    elif client['type'] in { 'CONSOLE', 'MONITOR'}:
                        client['conn'].send(bytes(body + '\r\n'))
                except IOError, e:
                    log(client['peer'], 'send: %s' % e.args[0])
                    self._remove(client)
        except Exception, e:
            print(format())
            print(e)

    def sendJSON(self, fields, clients=None, allClients=False):
        self.sendData(json.dumps(fields),
                clients=clients, allClients=allClients)

    def sendMessage(self, message):
        fields = [':M', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def sendError(self, message):
        fields = [':E', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def _remove(self, client):
        try:
            self.clients.pop(client['id'])
            client['alive'] = False
            client['conn'].close()
            log(client['peer'], 'disconnected')
        except Exception, e:
            print(e)
            print(format())

    def close(self):
        self.SERVER_ACTIVE = False
        for client in self.clients.values():
            self._remove(client)

    def handleData(self, client, opcode, data):
        log(client['peer'], 'message op=%d [%s]' % (opcode, data))
        pass

    def consoleCommand(self, client, data):
        log(client['peer'], 'console command %s' % (data))
        pass


def relay (ws,server,port):
    log(None, "connecting to rmonitor on %s:%d" % (server, port))
    s = socket.create_connection((server, port))
    log(None, 'Connected to rmonitor feed')
    rmon = s.makefile("rb")
    s.close()
    rmoncsv = csv.reader(rmon)
    while 1:
        try:
            fields = rmoncsv.next()
        except StopIteration:
            break
        if not fields: break
        print(json.dumps(fields))
        # Update the cache before sending the data.  This insures that
        # any new client will see this data, because new clients are
        # sent the entire cache before being added to the send list,
        # and locking prevents any all-clients sends in between.
        if   fields[0] == '$I':
            ws.new_client_data.clear()
            ws.new_client_data[''] = fields
        elif fields[0] in {'$A', '$G'}:
            ws.new_client_data[ '%s%3d' % (fields[0], fields[1]) ] = fields
        elif fields[0] in {'$B'}:
            ws.new_client_data[fields[0]] = fields
        ws.sendJSON(fields)
    log(None, 'Lost connection to rmonitor feed')
    rmon.close()

if __name__ == '__main__':
    # Handle command-line arguments
    server = '10.42.0.100'
    port   = 50000
    if len(sys.argv) > 1: server = sys.argv[1];
    if len(sys.argv) > 2: port   = sys.argv[2];

    # Compute and report server version
    try:
        server_ts = os.stat(sys.argv[0]).st_mtime
        server_version += time.strftime(', %m/%d/%Y, %H:%M:%S',
                time.localtime(server_ts))
    except Exception:
        pass
    log(None, "BigClock server v%s" % (server_version))

    # Start WebSocket and HTTP servers
    ws = WebSocketServer(9876)
    ws.startServer()
    httpd = BaseHTTPServer.HTTPServer(('', 8000), MyHTTPRequestHandler)
    httpd_thr = threading.Thread(target=httpd.serve_forever)
    httpd_thr.name = 'HTTP Listener'
    httpd_thr.daemon = True
    httpd_thr.start()

    # Run the relay
    while 1:
        try:
            relay(ws, server, port)
        except socket.error as e:
            log(None, str(e))
        time.sleep(5)
