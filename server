#!/usr/bin/env python

import BaseHTTPServer
import SimpleHTTPServer
import socket
import struct
import hashlib
import threading
import base64
import array
import time
import json
import os
import sys
import signal
import fcntl
import csv
from traceback import format_exc as format

server_version = '0.9'

global rmon_server, rmon_port
rmon_server = '10.42.0.100'
rmon_port   = 50000

global timezone
timezone = 'America/New_York'

maxMessageLen = 1024
wsPingPeriod = 5
wsMaxPings = 3
global RunRelay, Shutdown, ReExec
RunRelay = True
Shutdown = False
ReExec   = False


def log(peer, msg):
    preamble = time.strftime('%b %d %H:%M:%S')
    if peer != None:
        preamble += ' ' + peer
    print(preamble + ' ' + msg)

def cloexec(sock):
    flags = fcntl.fcntl(sock.fileno(), fcntl.F_GETFD)
    flags |= fcntl.FD_CLOEXEC
    fcntl.fcntl(sock.fileno(), fcntl.F_SETFD, flags)

class MyHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    protocol_version = "HTTP/1.0"
    def end_headers(self):
        self.send_my_headers()
        SimpleHTTPServer.SimpleHTTPRequestHandler.end_headers(self)

    def send_my_headers(self):
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "Thu, 01 Dec 1994 16:00:00 GMT")
        self.send_header("Max-Age", "0")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Cache-Control", "must-revalidate")

    def list_directory(self, path):
        self.send_error(404, "No permission to list directory")
        return None

    def copyfile(self, source, outputfile):
        name = source.name[ source.name.rfind('/')+1 : ]
        if not name.startswith('big-clock.'):
            return SimpleHTTPRequestHandler.copyfile(source, outputfile)
        s = os.fstat(source.fileno())
        stamp = time.strftime('%y%m%d-%H%M%S', time.localtime(s.st_mtime))
        outputfile.write(source.read().replace('@@@@@@-@@@@@@',stamp))

class MyHTTPServer(BaseHTTPServer.HTTPServer):
    def __init__(self, *args, **kwargs):
        BaseHTTPServer.HTTPServer.__init__(self, *args, **kwargs)
        cloexec(self.socket)

# WebSocket server code adapted from
# https://gist.github.com/sadatanwar/222d4643c25f72293461

class WSProtocolError(Exception): pass
class WSHandshakeError(WSProtocolError): pass

GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

def create_hash(key):
    reply = key + GUID
    sh1 = hashlib.sha1(reply)
    return sh1.digest()

def parse_headers(data, headers):
    lines = data.splitlines()
    for l in lines:
        if l == '':
            headers[None] = True
            return
        if '' not in headers:
            headers[''] = l.split()
            continue
        parts = l.split(": ", 1)
        if len(parts) == 2:
            headers[parts[0]] = parts[1]

# Conduct handshake.  Possible return values:
#   - 'WS'       WebSocket client
#   - 'CONSOLE'  console client (accepts console commands)
#   - 'MONITOR'  monitor client (read-only)
def handshake(conn, peer):
    log(peer, 'Starting handshake')
    headers = {}
    while None not in headers:
        data = conn.recv(1024)
        if not data: raise EOFError
        parse_headers(data, headers)
        if headers[''][0].upper() == 'CONSOLE':
            log(peer, 'console client')
            return 'CONSOLE'
        if headers[''][0].upper() == 'MONITOR':
            log(peer, 'monitor client')
            return 'MONITOR'

    if 'Sec-WebSocket-Key' not in headers:
        raise(WSHandshakeError('missing Sec-WebSocket-Key'))
    digest = create_hash(
        headers['Sec-WebSocket-Key']
    )
    encoded_data = base64.b64encode(digest)
    shake = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n"
    shake += "Upgrade: WebSocket\r\n"
    shake += "Connection: Upgrade\r\n"
    shake += "Sec-WebSocket-Accept: %s\r\n\r\n" % encoded_data
    conn.send(shake)
    log(peer, 'WebSocket handshake successful')
    return 'WS'


class WebSocketServer(object):
    def __init__(self, port):
        self.clients = {}
        self.port = port
        self.SERVER_ACTIVE = True
        self.POLLER_ACTIVE = False
        self.SEND_HEARTBEAT = False
        self.lock = threading.Lock()
        self.new_client_data = {}

    def _initClient(self,client):
        self.sendJSON([':V', server_version], clients=[client])
        self.sendJSON([':TZ', timezone], clients=[client])
        for item in sorted(self.new_client_data.items()):
            self.sendJSON(item[1], clients=[client])

    def addClient(self, conn, peer, clientType):
        try:
            clientCode = conn.__hash__()
            client = {
                    'id': clientCode,
                    'peer': peer,
                    'conn': conn,
                    'type': clientType,
                    'squelch': False,
                    'alive': True,
                    'last_pong': time.time(),
                    'user_agent'   : '???',
                    'version_html' : '???',
                    'version_css'  : '???',
                    'version_js'   : '???',
                    'options'      : '-',
                    }
            with self.lock:
                self._initClient(client)
                self.clients[clientCode] = client
                conn = None
                if clientType == 'WS':
                    client_thr = threading.Thread(target=self._wsClient,
                            args=(client,))
                    client_thr.name = 'client ' + peer
                    client_thr.daemon = True
                    client_thr.start()
                if clientType == 'CONSOLE':
                    client['squelch'] = True
                    client_thr = threading.Thread(target=self._consClient,
                            args=(client,))
                    client_thr.name = 'client ' + peer
                    client_thr.daemon = True
                    client_thr.start()
                if not self.POLLER_ACTIVE:
                    self.POLLER_ACTIVE = True
                    poller_thr = threading.Thread(target=self._poll)
                    poller_thr.name = 'poller'
                    poller_thr.daemon = True
                    poller_thr.start()
        except Exception, e:
            if conn: conn.close()
            log(peer, str(type(e)))
            print(format())
            print(e)

    def _bindClient(self):
        log(None, 'waiting connection')
        s = socket.socket()
        cloexec(s)
        s.settimeout(5)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', self.port))
        s.listen(10)
        while self.SERVER_ACTIVE:
            try:
                conn, addr = s.accept()
            except Exception, e:
                err = e.args[0]
                if err == 'timed out':
                    continue
                print(format())
                print(e)
                self.SERVER_ACTIVE = False
                return
            peer = '%s:%d' % addr
            log(peer, 'Client connected')
            try:
                cloexec(conn)
                conn.settimeout(5)
                clientType = handshake(conn, peer)
            except Exception, e:
                conn.close()
                log(peer, str(type(e)))
                print(format())
                print(e)
            self.addClient(conn, peer, clientType)
        log(None, 'Shutting down WS server port: %s' % self.port)
        return

    def _wsClient(self, client):
        conn = client['conn']
        payload = array.array('B')
        datatype = 0
        while client['alive']:
            try:
                # receive header
                data = conn.recv(2)
                if not data: raise EOFError
                head1, head2 = struct.unpack('!BB', data)
                fin = bool(head1 & 0b10000000)
                isctrl = head1 & 0b00001000
                opcode = head1 & 0b00001111
                length = head2 & 0b01111111
                if length == 126:
                    data = conn.recv(2)
                    if not data: raise EOFError
                    length, = struct.unpack('!H', data)
                elif length == 127:
                    data = conn.recv(8)
                    if not data: raise EOFError
                    length, = struct.unpack('!Q', data)
                mask_bits = conn.recv(4)
                if not mask_bits: raise EOFError
                mask_bits = bytearray(mask_bits)

                # validation
                if not payload and not opcode:
                    raise WSProtocolError('no opcode in initial packet')
                if payload and opcode and not isctrl:
                    raise WSProtocolError('opcode in non-initial packet')
                if isctrl and not fin:
                    raise WSProtocolError('fragmented control packet')
                if not head2 & 0b10000000:
                    raise WSProtocolError('client data not masked')
                if isctrl and length > 125:
                    raise WSProtocolError('control message too long (%d > 125)'
                            % (length))
                if length > maxMessageLen:
                    raise WSProtocolError('packet too long (%d > %d)'
                            % (length, maxMessageLen))
                if length > maxMessageLen - len(payload):
                    raise WSProtocolError('message too long (%d + %d > %d)'
                            % (len(payload), length, maxMessageLen))

                # receive and decode data
                data = conn.recv(length)
                if not data: raise EOFError
                data = bytearray(data)
                DECODED = []
                for i in range(0, len(data)):
                    DECODED.append(data[i] ^ mask_bits[i % 4])

            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if isctrl:
                data = array.array('B', DECODED).tostring()
            else:
                payload.extend(DECODED)
                if opcode: datatype = opcode
                if not fin: continue
                data = payload.tostring()
                del payload[:]

            # handle complete messages
            if opcode == 0x8: # close
                if len(data) >= 2:
                    reason, = struct.unpack('!H', data[0:2])
                    message = data[2:]
                    log(client['peer'], 'connection closed (%d): %s'
                            % (reason,message))
                else:
                    log(client['peer'], 'connection closed')
                self._remove(client)
            elif opcode == 0x9: # ping
                self.sendData(data, opcode=0xa, clients=[client])
            elif opcode == 0xa or (not isctrl and data == "pong"): # pong
                client['last_pong'] = time.time()
                log(client['peer'], 'pong')
            elif isctrl:
                log(client['peer'], 'unknown control message %x' % opcode)
            else:
                self.handleData(client, datatype, data)

    def _consClient(self, client):
        conn = client['conn']
        conn.setblocking(True)
        f = conn.makefile('rU')
        while client['alive']:
            try:
                data = f.readline().strip()
                if not data: raise EOFError
            except socket.timeout:
                continue
            except EOFError:
                log(client['peer'], 'disconnected')
                self._remove(client)
                break
            except IOError, e:
                log(client['peer'], 'recv: %s' % e.args[0])
                self._remove(client)
                break
            except Exception, e:
                log(client['peer'], '%s: %s' % (str(type(e)), e.args[0]))
                print(format())
                print(e)
                self._remove(client)
                break

            if data == "pong":
                client['last_pong'] = time.time()
            elif data[0] == ':':
                self.consoleCommand(client, data[1:].split())
            elif data[0] == '+':
                self.sendMessage(data[1:])
            elif data[0] == '!':
                self.sendError(data[1:])
            else:
                self.handleData(client, 1, data)

    def _poll(self):
        pingTimeout = wsPingPeriod * wsMaxPings + 3
        try:
            while self.SERVER_ACTIVE:
                log(None, 'Pinging %d clients' % len(self.clients))
                self.sendData('BigClock', opcode=0x9)
                now = time.time()
                for client in self.clients.values():
                    if client['type'] != 'WS': continue
                    if not client['alive']: continue
                    if now - client['last_pong'] > pingTimeout:
                        log(client['peer'], 'Client timed out')
                        self._remove(client)
                with self.lock:
                    if len(self.clients) == 0:
                        log(None, 'No Clients, shutting down poller')
                        self.POLLER_ACTIVE = False
                        return
                if self.SEND_HEARTBEAT:
                    while time.time() < now + wsPingPeriod:
                        self.sendJSON([])
                        time.sleep(1)
                else:
                    time.sleep(wsPingPeriod)
        except Exception, e:
            self.POLLER_ACTIVE = False
            print(format())
            print(e)

    def startServer(self):
        ws_server_thr = threading.Thread(target=self._bindClient)
        ws_server_thr.name = 'WS Listener'
        ws_server_thr.daemon = True
        ws_server_thr.start()

    def sendData(self, data, fin=True, opcode=1, masking_key=False,
            clients=None, allClients=False):
        if fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')
        if 0x3 <= opcode <= 0x7 or 0xB <= opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------++-+-------------+-------------------------------+
        ## |F|R|R|R| opcode||M| Payload len |    Extended payload length    |
        ## |I|S|S|S|  (4)  ||A|     (7)     |             (16/63)           |
        ## |N|V|V|V|       ||S|             |   (if payload len==126/127)   |
        ## | |1|2|3|       ||K|             |                               |
        ## +-+-+-+-+-------++-+-------------+ - - - - - - - - - - - - - - - +
        ## +-+-+-+-+--------------------------------------------------------+
        ## |     Extended payload length continued, if payload len == 127   |
        ## + - - - - - - - - - - - - - - - +--------------------------------+
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        try:
            header = struct.pack('!B', ((fin << 7)
                                        | (0 << 6)
                                        | (0 << 5)
                                        | (0 << 4)
                                        | opcode))
            if masking_key:
                mask_bit = 1 << 7
            else:
                mask_bit = 0

            length = len(data)
            if length < 126:
                header += struct.pack('!B', (mask_bit | length))
            elif length < (1 << 16):
                header += struct.pack('!B', (mask_bit | 126)) + struct.pack('!H', length)
            elif length < (1 << 63):
                header += struct.pack('!B', (mask_bit | 127)) + struct.pack('!Q', length)

            body = data
            if clients == None:
                with self.lock: clients = self.clients.values()
                if not allClients:
                    clients = [c for c in clients if not c['squelch']]
            for client in clients:
                try:
                    if client['type'] == 'WS':
                        client['conn'].send(bytes(header + body))
                    elif client['type'] in { 'CONSOLE', 'MONITOR'}:
                        client['conn'].send(bytes(body + '\r\n'))
                except IOError, e:
                    log(client['peer'], 'send: %s' % e.args[0])
                    self._remove(client)
        except Exception, e:
            print(format())
            print(e)

    def sendJSON(self, fields, clients=None, allClients=False):
        self.sendData(json.dumps(fields),
                clients=clients, allClients=allClients)

    def sendMessage(self, message):
        fields = [':M', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def sendError(self, message):
        fields = [':E', message]
        self.new_client_data[fields[0]] = fields
        self.sendJSON(fields, allClients=True)

    def _remove(self, client):
        try:
            self.clients.pop(client['id'])
            client['alive'] = False
            client['conn'].close()
        except Exception, e:
            print(e)
            print(format())

    def close(self):
        self.SERVER_ACTIVE = False
        for client in self.clients.values():
            self._remove(client)

    def handleData(self, client, opcode, data):
        if opcode != 1:
            log(client['peer'], 'unsupported message opcode %d' % opcode)
            return
        try:
            fields = json.loads(data)
        except Exception, e:
            log(client['peer'], str(type(e)))
            return
        if fields[0] == '%O':
            client['options'] = fields[1]
            log(client['peer'], 'Options: %s' % fields[1])
        elif fields[0] == '%U':
            client['user_agent'] = fields[1]
            log(client['peer'], 'User-Agent: %s' % fields[1])
        elif fields[0] == '%V':
            client['version_html'] = fields[1]
            client['version_css' ] = fields[2]
            client['version_js'  ] = fields[3]
            log(client['peer'], 'Version: HTML %s / CSS %s / JS %s' % (
                fields[1], fields[2], fields[3]))
        else:
            log(client['peer'], 'unsupported message type %s' % fields[0])

    def _findClient(self, spec):
        for c in self.clients.values():
            if spec == "%x" % c['id']: return c
            if spec == c['peer']:      return c
        return None

    def consoleCommand(self, client, fields):
        global RunRelay, Shutdown, ReExec
        global rmon_server, rmon_port, timezone
        log(client['peer'], 'console command %s' % (fields))
        if fields[0] == "version":
            self.sendData("BigClock server v%s" % (server_version),
                    clients=[client])

        elif fields[0] == "server":
            if len(fields) >= 2:
                rmon_server = fields[1]
                if len(fields) > 2: rmon_port = int(fields[2])
            self.sendData("rmonitor host %s port %d" % (
                rmon_server, rmon_port), clients=[client])
            if len(fields) >= 2:
                self.sendData(":reconnect to apply", clients=[client])

        elif fields[0] == "timezone":
            if len(fields) >= 2:
                timezone = fields[1]
                self.sendJSON([':TZ', timezone])
            self.sendData("timezone %s" % timezone, clients=[client])

        elif fields[0] == "options":
            if len(fields) < 2:
                self.sendData("options requires a client", clients=[client])
                return
            if len(fields) < 3:
                self.sendData("options required", clients=[client])
                return
            c = self._findClient(fields[1])
            if not c:
                self.sendData("unknown client %s" % spec, clients=[client])
                return
            self.sendData("changing client %x options" % c['id'],
                    clients=[client])
            self.sendJSON([':OPT', fields[2]], clients=[c])

        elif fields[0] == "kick":
            if len(fields) < 2:
                self.sendData("kick requires a client", clients=[client])
                return
            for spec in fields[1:]:
                c = self._findClient(spec)
                if not c:
                    self.sendData("unknown client %s" % spec, clients=[client])
                    continue
                self.sendData("kicking %x" % c['id'], clients=[client])
                log(c['peer'], "disconnected via console %s" % client['peer'])
                self._remove(c)

        elif fields[0] == "refresh":
            if len(fields) >= 2:
                cc = filter(None, [ self._findClient(c) for c in fields[1:] ])
                clist = ','.join(['%x' % c['id'] for c in cc])
                self.sendData('Refreshing %s' % clist, clients=[client])
            else:
                cc = None
                self.sendData('Refreshing all clients', clients=[client])
            self.sendJSON([':V', server_version], clients=cc)
            for item in sorted(self.new_client_data.items()):
                self.sendJSON(item[1], clients=cc)

        elif fields[0] == "reload":
            if len(fields) >= 2:
                cc = filter(None, [ self._findClient(c) for c in fields[1:] ])
                clist = ','.join(['%x' % c['id'] for c in cc])
                self.sendData('Reloading %s' % clist, clients=[client])
            else:
                cc = None
                self.sendData('Reloading all clients', clients=[client])
            self.sendJSON([':R'], clients=cc)

        elif fields[0] == "reconnect":
            self.sendData('restarting rmonitor relay', clients=[client])
            RunRelay = False
            os.kill(os.getpid(), signal.SIGHUP)

        elif fields[0] == "restart":
            self.sendData('restarting server', clients=[client])
            ReExec = True
            Shutdown = True
            RunRelay = False
            os.kill(os.getpid(), signal.SIGHUP)

        elif fields[0] == "shutdown":
            self.sendData('shutting down server', clients=[client])
            Shutdown = True
            RunRelay = False
            os.kill(os.getpid(), signal.SIGHUP)

        elif fields[0] == "squelch":
            client['squelch'] = True

        elif fields[0] == "unsquelch":
            client['squelch'] = False

        elif fields[0] == "clients":
            msg =  "      Client ID  Type     LastSeen  IP Address : Port\n"
            msg += "   ============  =======  ========  =====================\n"
            for c in self.clients.values():
                fl = '>' if c is client else '-' if not c['alive'] else ' '
                fl += 'S' if c['squelch'] else ' '
                ts = time.strftime('%H:%M:%S', time.localtime(c['last_pong']))
                msg += "%s %12x  %-7s  %-8s  %s\n" % (
                        fl, c['id'], c['type'], ts, c['peer'])
                if len(fields) > 1 and fields[1] == '-v' and c['type'] == 'WS':
                    msg += "   %s\n   HTML %s / CSS %s / JS %s\n   %s\n\n" % (
                            c['user_agent'], c['version_html'],
                            c['version_css'], c['version_js'], c['options'])
            self.sendData(msg, clients=[client])

        elif fields[0] == "threads":
            current = threading.current_thread()
            msg =  "      Thread ID  Description\n"
            msg += "   ============  ===============\n"
            for t in threading.enumerate():
                fl =  '>' if t is current else ' '
                fl += 'D' if t.daemon else ' '
                msg += "%s %12x  %s\n" % (fl, t.ident, t.name)
            self.sendData(msg, clients=[client])

        elif fields[0] == "help":
            self.sendData("""
The following commands are available
  +<msg>                  set status message to <msg>
  !<msg>                  set error message to <msg>
  :server [host [port]]   show or change rmonitor server (:reconnect to apply)
  :timezone [zone]        show or change timezone reported to clients
  :options client opts    change client config options
  :kick client...         disconnect a client
  :refresh [client...]    resend cached data to one or all clients
  :reload [client...]     tell one or all clients to reload page
  :reconnect              reconnect to rmonitor feed
  :restart                restart server
  :shutdown               shut down server
  :squelch                disable monitor output
  :unsquelch              enable monitor output
  :clients [-v]           list connected clients
  :threads                list active threads
  :help                   show this help message
  :version                show server version
""", clients=[client])
        else:
            self.sendData('Unrecognized command %s' % fields[0])


class StopRelayException(Exception): pass
def StopRelaySignal(signal, frame): raise StopRelayException
def relay (ws,server,port):
    log(None, "connecting to rmonitor on %s:%d" % (server, port))
    ws.SEND_HEARTBEAT = True
    s = socket.create_connection((server, port))
    log(None, 'Connected to rmonitor feed')
    ws.sendError('')
    ws.SEND_HEARTBEAT = False
    rmon = s.makefile("rb")
    s.close()
    rmoncsv = csv.reader(rmon)
    while RunRelay:
        try:
            fields = rmoncsv.next()
        except StopIteration:
            log(None, 'Lost connection to rmonitor feed')
            ws.sendError('Lost rmonitor feed')
            break
        if not fields:
            log(None, 'Lost connection to rmonitor feed')
            ws.sendError('Lost rmonitor feed')
            break
        print(json.dumps(fields))
        # Update the cache before sending the data.  This insures that
        # any new client will see this data, because new clients are
        # sent the entire cache before being added to the send list,
        # and locking prevents any all-clients sends in between.
        if   fields[0] == '$I':
            ws.new_client_data.clear()
            ws.new_client_data[''] = fields
        elif fields[0] in {'$A' }:
            ws.new_client_data[ '%s%s' % (fields[0], fields[1]) ] = fields
        elif fields[0] in {'$G'}:
            ws.new_client_data[ '%s%3d' % (fields[0], int(fields[1])) ] = fields
        elif fields[0] in {'$B'}:
            ws.new_client_data[fields[0]] = fields
        ws.sendJSON(fields)
    log(None, 'relay server exiting')
    rmon.close()

if __name__ == '__main__':
    # Handle command-line arguments
    if len(sys.argv) > 1: rmon_server = sys.argv[1];
    if len(sys.argv) > 2: rmon_port   = sys.argv[2];

    # Compute and report server version
    try:
        ts = os.stat(sys.argv[0]).st_mtime
        server_version += time.strftime('-%y%m%d-%H%M%S', time.localtime(ts))
    except Exception:
        pass
    log(None, "BigClock server v%s" % (server_version))

    signal.signal(signal.SIGHUP, StopRelaySignal)
    # Start WebSocket and HTTP servers
    ws = WebSocketServer(9876)
    ws.startServer()
    httpd = MyHTTPServer(('', 8000), MyHTTPRequestHandler)
    httpd_thr = threading.Thread(target=httpd.serve_forever)
    httpd_thr.name = 'HTTP Listener'
    httpd_thr.daemon = True
    httpd_thr.start()

    # Run the relay
    while not Shutdown:
        try:
            try:
                RunRelay = True
                relay(ws, rmon_server, rmon_port)
            except socket.error as e:
                log(None, str(e))
                ws.sendError('Lost rmonitor feed')
            ws.SEND_HEARTBEAT = True
            time.sleep(5)
        except StopRelayException:
            log(None, "relay server exited on SIGHUP")
    httpd.shutdown()
    ws.close()
    if ReExec:
        if sys.argv[0] == '' or sys.argv[0] == '-c':
            log(None, "Unable to reexec from non-file")
        else:
            os.execv(sys.argv[0], sys.argv)
