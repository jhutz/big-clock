#!/usr/bin/env python

import BaseHTTPServer
import SimpleHTTPServer
import socket
import struct
import hashlib
import threading
import base64
import array
import time
import json
import os
import sys
import csv
from traceback import format_exc as format

server_version = '0.9'

def log(peer, msg):
    preamble = time.strftime('%b %d %H:%M:%S')
    if peer != None:
        preamble += ' ' + peer
    print(preamble + ' ' + msg)


class MyHTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    protocol_version = "HTTP/1.0"
    def end_headers(self):
        self.send_my_headers()

        SimpleHTTPServer.SimpleHTTPRequestHandler.end_headers(self)

    def send_my_headers(self):
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "Thu, 01 Dec 1994 16:00:00 GMT")
        self.send_header("Max-Age", "0")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Cache-Control", "must-revalidate")

# WebSocket server code adapted from
# https://gist.github.com/sadatanwar/222d4643c25f72293461

GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

def create_hash(key):
    reply = key + GUID
    sh1 = hashlib.sha1(reply)
    return sh1.digest()

def parse_headers(data, headers):
    lines = data.splitlines()
    for l in lines:
        if l == '':
            headers[None] = True
            return
        if '' not in headers:
            headers[''] = l.split()
            continue
        parts = l.split(": ", 1)
        if len(parts) == 2:
            headers[parts[0]] = parts[1]


def readData(conn):
    try:
        data = conn.recv(2)
        head1, head2 = struct.unpack('!BB', data)
        fin = bool(head1 & 0b10000000)
        opcode = head1 & 0b00001111
        if opcode == 1:
            length = head2 & 0b01111111
            if length == 126:
                data = conn.recv(2)
                length, = struct.unpack('!H', data)
            elif length == 127:
                data = conn.recv(8)
                length, = struct.unpack('!Q', data)

            mask_bits = conn.recv(4)
            mask_bits = bytearray(mask_bits)
            data = conn.recv(length)
            data = bytearray(data)
            DECODED = []
            for i in range(0, len(data)):
                DECODED.append(data[i] ^ mask_bits[i % 4])
            DECODED = array.array('B', DECODED).tostring()
            if fin:
                return DECODED
    except Exception, e:
        err = e.args[0]
        # this next if/else is a bit redundant, but illustrates how the
        # timeout exception is setup
        if err == 'timed out':
            pass
        elif err == 10053:
            return None
        else:
            print(e)
            return None


def handshake(conn, peer):
    log(peer, 'Starting handshake')
    headers = {}
    while None not in headers:
        data = conn.recv(1024)
        if not data:
            log(peer, 'client disconnected during handshake')
            return None
        parse_headers(data, headers)

    if 'Sec-WebSocket-Key' not in headers:
        log(peer, 'WebSocket handshake failed: missing Sec-WebSocket-Key')
        return False
    digest = create_hash(
        headers['Sec-WebSocket-Key']
    )
    encoded_data = base64.b64encode(digest)
    shake = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n"
    shake += "Upgrade: WebSocket\r\n"
    shake += "Connection: Upgrade\r\n"
    shake += "Sec-WebSocket-Accept: %s\r\n\r\n" % encoded_data
    conn.send(shake)
    log(peer, 'WebSocket handshake successful')
    return True


class WebSocketServer(object):
    def __init__(self, port):
        self.clients = {}
        self.port = port
        self.SERVER_ACTIVE = True
        self.POLLER_ACTIVE = False
        self.lock = threading.Lock()

    def _bindClient(self):
        log(None, 'waiting connection')
        s = socket.socket()
        s.settimeout(5)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('', self.port))
        s.listen(10)
        while self.SERVER_ACTIVE:
            try:
                conn, addr = s.accept()
            except Exception, e:
                err = e.args[0]
                if err == 'timed out':
                    continue
                print(format())
                print(e)
                self.SERVER_ACTIVE = False
                return
            peer = '%s:%d' % addr
            log(peer, 'Client connected')
            try:
                conn.settimeout(5)
                if not handshake(conn, peer):
                    conn.close()
                    continue
                clientCode = conn.__hash__()
                client = {
                        'id': clientCode,
                        'peer': peer,
                        'conn': conn,
                        'failCount': 0,
                        'alive': True
                        }
                with self.lock:
                    self.clients[clientCode] = client
                    conn = None
                    if not self.POLLER_ACTIVE:
                        self.POLLER_ACTIVE = True
                        poller_thr = threading.Thread(target=self._poll)
                        poller_thr.daemon = True
                        poller_thr.start()
                self.sendJSON([':V', server_version], clients=[client])
            except Exception, e:
                if conn: conn.close()
                log(peer, str(type(e)))
                print(format())
                print(e)
        log(None, 'Shutting down WS server port: %s' % self.port)
        return

    def _poll(self):
        try:
            while self.SERVER_ACTIVE:
                log(None, 'Pinging %d clients' % len(self.clients))
                self.sendData('ping')
                for client in self.clients.values():
                    try:
                        if client['alive']:
                            reply = readData(client['conn'])
                            if reply is None:
                                log(client['peer'], 'no reply')
                                client['failCount'] += 1
                                if client['failCount'] > 2:
                                    client['alive'] = False
                                    self._remove(client)
                            elif reply == 'pong':
                                client['alive'] = True
                        else:
                            log(client['peer'], 'Client timed out')
                            self._remove(client)
                    except Exception, e:
                        log(client['peer'], str(type(e)))
                        client['alive'] = False
                        self._remove(client)
                        print(format())
                        print(e)
                with self.lock:
                    if len(self.clients) == 0:
                        log(None, 'No Clients, shutting down poller')
                        self.POLLER_ACTIVE = False
                        return
                time.sleep(15)
        except Exception, e:
            self.POLLER_ACTIVE = False
            print(format())
            print(e)

    def startServer(self):
        ws_server_thr = threading.Thread(target=self._bindClient)
        ws_server_thr.daemon = True
        ws_server_thr.start()

    def readData(self):
        reply = []
        for client in self.clients.values():
            reply.append(readData(client['conn']))

    def sendData(self, data, fin=True, opcode=1, masking_key=False, clients=None):
        if fin > 0x1:
            raise ValueError('FIN bit parameter must be 0 or 1')
        if 0x3 <= opcode <= 0x7 or 0xB <= opcode:
            raise ValueError('Opcode cannot be a reserved opcode')

        ## +-+-+-+-+-------++-+-------------+-------------------------------+
        ## |F|R|R|R| opcode||M| Payload len |    Extended payload length    |
        ## |I|S|S|S|  (4)  ||A|     (7)     |             (16/63)           |
        ## |N|V|V|V|       ||S|             |   (if payload len==126/127)   |
        ## | |1|2|3|       ||K|             |                               |
        ## +-+-+-+-+-------++-+-------------+ - - - - - - - - - - - - - - - +
        ## +-+-+-+-+--------------------------------------------------------+
        ## |     Extended payload length continued, if payload len == 127   |
        ## + - - - - - - - - - - - - - - - +--------------------------------+
        ## + - - - - - - - - - - - - - - - +-------------------------------+
        ## |                               |Masking-key, if MASK set to 1  |
        ## +-------------------------------+-------------------------------+
        ## | Masking-key (continued)       |          Payload Data         |
        ## +-------------------------------- - - - - - - - - - - - - - - - +
        ## :                     Payload Data continued ...                :
        ## + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        ## |                     Payload Data continued ...                |
        ## +---------------------------------------------------------------+
        try:
            header = struct.pack('!B', ((fin << 7)
                                        | (0 << 6)
                                        | (0 << 5)
                                        | (0 << 4)
                                        | opcode))
            if masking_key:
                mask_bit = 1 << 7
            else:
                mask_bit = 0

            length = len(data)
            if length < 126:
                header += struct.pack('!B', (mask_bit | length))
            elif length < (1 << 16):
                header += struct.pack('!B', (mask_bit | 126)) + struct.pack('!H', length)
            elif length < (1 << 63):
                header += struct.pack('!B', (mask_bit | 127)) + struct.pack('!Q', length)

            body = data
            if clients == None:
                clients = self.clients.values()
            for client in clients:
                try:
                    client['conn'].send(bytes(header + body))
                except IOError, e:
                    log(client['peer'], 'send: %s' % e.args[0])
                    self._remove(client)
        except Exception, e:
            print(format())
            print(e)

    def sendJSON(self, fields, clients=None):
        self.sendData(json.dumps(fields), clients=clients)

    def _remove(self, client):
        try:
            self.clients.pop(client['id'])
            client['conn'].close()
            log(client['peer'], 'disconnected')
        except Exception, e:
            print(e)
            print(format())

    def close(self):
        self.SERVER_ACTIVE = False
        for client in self.clients.values():
            self._remove(client)


def relay (ws,server,port):
    log(None, "connecting to rmonitor on %s:%d" % (server, port))
    s = socket.create_connection((server, port))
    log(None, 'Connected to rmonitor feed')
    rmon = s.makefile("rb")
    s.close()
    rmoncsv = csv.reader(rmon)
    while 1:
        try:
            fields = rmoncsv.next()
        except StopIteration:
            break
        if not fields: break
        print(json.dumps(fields))
        ws.sendJSON(fields)
    log(None, 'Lost connection to rmonitor feed')
    rmon.close()

if __name__ == '__main__':
    # Handle command-line arguments
    server = '10.42.0.100'
    port   = 50000
    if len(sys.argv) > 1: server = sys.argv[1];
    if len(sys.argv) > 2: port   = sys.argv[2];

    # Compute and report server version
    try:
        server_ts = os.stat(sys.argv[0]).st_mtime
        server_version += time.strftime(', %m/%d/%Y, %H:%M:%S',
                time.localtime(server_ts))
    except Exception:
        pass
    log(None, "BigClock server v%s" % (server_version))

    # Start WebSocket and HTTP servers
    ws = WebSocketServer(9876)
    ws.startServer()
    httpd = BaseHTTPServer.HTTPServer(('', 8000), MyHTTPRequestHandler)
    httpd_thr = threading.Thread(target=httpd.serve_forever)
    httpd_thr.daemon = True
    httpd_thr.start()

    # Run the relay
    while 1:
        try:
            relay(ws, server, port)
        except socket.error as e:
            log(None, str(e))
        time.sleep(5)
